%
% API Documentation for nMOLDYN
% Module nMOLDYN.Core.Mathematics
%
% Generated by epydoc 3.0.1
% [Thu Oct  8 17:00:00 2009]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}|(}
\section{Module nMOLDYN.Core.Mathematics}

    \label{nMOLDYN:Core:Mathematics}
\begin{alltt}
This modules implements the mathematics-related classes, functions and procedures.

Classes:
    * QVectors: the class that actually performs the q vectors generation.

Functions:
    * differentiate      : performs a numerical differentiation of 1D Numeric array
    * correlation        : performs the numerical correlation between two 1D Numeric arrays
    * convolution        : performs the numerical convolution between two 1D Numeric arrays
    * FFT                : performs the FFT of a 1D Numeric array
    * invFFT             : performs the inverse FFT of a 1D Numeric array
    * gaussianWindow     : performs a Gaussian smoothing of 1D Numeric array.
    * factorial          : computes factorial (n) where n is an integer.
    * basisVectors       : computes the basis vectors of the simulation cell from a set of values defining its geometry (3 distances and 3 angles).
    * randomPointInCircle: returns a vector within a circle of radius {\textbar}r{\textbar} and orthogonal to a given direction.
    * randomDirection2D  : returns a normalized vector generated from a unit circle orthogonal to a given direction.
    * randomPlane2D      : generates a normalized random q-vector on a plane defined by vect1, vect2.
    * qVectorGenerator   : sets up and returns a set of q vectors generated from different user-defined parameters.
    * sphericalHarmonics : calculates the spherical functions Y from a set of j, m, n Wigner indexes
    * preparePP          : sets up the calculation of spherical harmonics.
\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{nMOLDYN:Core:Mathematics:differentiate}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.differentiate \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{differentiate}(\textit{inputSeries}, \textit{order}, \textit{dx})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns the numerical derivative of order {\textbar}order{\textbar} of 
    the signal {\textbar}inputSeries{\textbar} using the differentiation 
    step {\textbar}dx{\textbar}.

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxxxxxxx}

          \item[inputSeries]

          the signal to differentiate.

          \item[order]

          an integer in [1,5] specifying the numerical differentiation 
          order.

          \item[dx]

          a float specifying the differentiation step. Assumed to be 
          constant over all the spectrum.

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      the differentiated signal.

      {\it (type=NumPy array)}

      \end{quote}

\textbf{See Also:} M. Abramowitz, I.A. Stegun; 'Handbook of mathematical functions', Dover, 
New-York, 1972 p.914.



    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:myautocorrelation}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.myautocorrelation \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{myautocorrelation}(\textit{inputSeries})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:correlation}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.correlation \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{correlation}(\textit{inputSeries1}, \textit{inputSeries2}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns the numerical correlation between 
    {\textbar}inputSeries1{\textbar} and {\textbar}inputSeries2{\textbar} 
    multidimensional NumPy arrays.

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxxxxxxxx}

          \item[inputSeries1]

          the first signal

            {\it (type=NumPy array)}

          \item[inputSeries2]

          if not None, the second signal to correlate with 
          {\textbar}inputSeries1{\textbar} otherwise the correlation will 
          be an autocorrelation.

            {\it (type=NumPy array)}

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      an array (length({\textbar}inputSeries1{\textbar})) storing the 
      result of the correlation.

      {\it (type=NumPy array)}

      \end{quote}

\textbf{Notes:}
\begin{quote}
  \begin{itemize}

  \item
    \setlength{\parskip}{0.6ex}
if {\textbar}inputSeries1{\textbar} is a multidimensional array the 
correlation calculation is performed on the first dimension.



  \item The correlation is computed using the FCA algorithm.



\end{itemize}

\end{quote}

    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:convolution}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.convolution \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{convolution}(\textit{inputSeries1}, \textit{inputSeries2})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns the numerical convolution between 
    {\textbar}inputSeries1{\textbar} and {\textbar}inputSeries2{\textbar} 
    one-dimensional NumPy arrays.

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxxxxxxxx}

          \item[inputSeries1]

          the first signal

            {\it (type=NumPy array)}

          \item[inputSeries2]

          the second signal to convolve with 
          {\textbar}inputSeries1{\textbar}.

            {\it (type=NumPy array)}

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      an array (length({\textbar}inputSeries1{\textbar})) storing the 
      result of the convolution.

      {\it (type=NumPy array)}

      \end{quote}

\textbf{Notes:}
\begin{quote}
  \begin{itemize}

  \item
    \setlength{\parskip}{0.6ex}
if {\textbar}inputSeries1{\textbar} is a multidimensional array the 
convolution calculation is performed on the first dimension.



  \item the convolution is computed using the convolve function of NumPy package.



\end{itemize}

\end{quote}

    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:FFT}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.FFT \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FFT}(\textit{inputSeries})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns the FFT of {\textbar}inputSeries{\textbar} multidimensional 
    NumPy array.

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxxxxxxx}

          \item[inputSeries]

          the array on which to computes the FFT.

            {\it (type=NumPy array)}

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      the FFT transformed array.

      {\it (type=NumPy array)}

      \end{quote}

\textbf{Note:} the FFT is computed using the fft function of Scientific.FFT package.



    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:invFFT}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.invFFT \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{invFFT}(\textit{inputSeries})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns the inverse FFT of {\textbar}inputSeries{\textbar} 
    multidimensional NumPy array.

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxxxxxxx}

          \item[inputSeries]

          the array on which to computes the inverse FFT.

            {\it (type=NumPy array)}

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      the inverse FFT transformed array.

      {\it (type=NumPy array)}

      \end{quote}

\textbf{Note:} the inverse FFT is computed using the inverse\_fft function of 
Scientific.FFT package.



    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:gaussianWindow}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.gaussianWindow \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{gaussianWindow}(\textit{inputSeries}, \textit{alpha})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns a smoothed signal using {\textbar}inputSeries{\textbar} input 
    signal and a gaussian kernel of width {\textbar}alpha{\textbar}.

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxxxxxxx}

          \item[inputSeries]

          the signal to smooth.

            {\it (type=NumPy array)}

          \item[alpha]

          a float specifying the width of the Gaussian.

            {\it (type=float)}

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      an array (length = 2*len({\textbar}inputSeries{\textbar}) - 1) 
      containing the smoothed signal.

      {\it (type=NumPy array)}

      \end{quote}

    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:factorial}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.factorial \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{factorial}(\textit{n})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns n!

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{x}

          \item[n]

          the n of n!.

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      n!.

      {\it (type=integer)}

      \end{quote}

    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:preparePP}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.preparePP \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{preparePP}(\textit{j}, \textit{m}, \textit{n})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Intermediate function used to setup the calculation of spherical 
    harmonics.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:sphericalCoordinates}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.sphericalCoordinates \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{sphericalCoordinates}(\textit{x}, \textit{y}, \textit{z})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    This function returns the r, theta and phi spherical coordinates from 
    the x, y z cartesian coordinates.

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{x}

          \item[x]

          the cartesian x.

            {\it (type=float)}

          \item[y]

          the cartesian y.

            {\it (type=float)}

          \item[z]

          the cartesian z.

            {\it (type=float)}

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      the r, theta and phi spherical coordinates..

      {\it (type=a list of three floats)}

      \end{quote}

    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:changeBasis}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.changeBasis \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{changeBasis}(\textit{pt}, \textit{op}, \textit{ip}, \textit{jp}, \textit{kp})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    This function return the coordinates

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xx}

          \item[pt]

          the coordinates of the point in the old basis.

            {\it (type=Scientific Vector)}

          \item[op]

          the coordinates of the new origin in the old basis.

            {\it (type=Scientific Vector)}

          \item[ip]

          the coordinates of the new x axis in the old basis.

            {\it (type=Scientific Vector)}

          \item[jp]

          the coordinates of the new y axis in the old basis.

            {\it (type=Scientific Vector)}

          \item[kp]

          the coordinates of the new z axis in the old basis.

            {\it (type=Scientific Vector)}

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      the coordinates of the point in the new basis.

      {\it (type=Scientific Vector)}

      \end{quote}

    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:basisVectors}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.basisVectors \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{basisVectors}(\textit{parameters})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns the basis vectors for the simulation cell from the six 
    crystallographic parameters.

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxxxxxx}

          \item[parameters]

          a list of six floats defining the simulation cell geometry.

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      a list of three Scientific.Geometry.Vector objects representing 
      respectively a, b and c basis vectors.

      {\it (type=list)}

      \end{quote}

    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:randomPointInCircle}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.randomPointInCircle \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{randomPointInCircle}(\textit{r}, \textit{axis})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns a vector drawn from an uniform distribution within a circle of 
    radius {\textbar}r{\textbar} and orthogonal to vector 
    {\textbar}axis{\textbar}.

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxx}

          \item[r]

          float specifying the radius of the circle.

            {\it (type=float)}

          \item[axis]

          the axis orthogonal to the plane where the vectors have to be 
          generated.

            {\it (type=Scientific.Geometry.Vector object)}

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      a vector pointing to a random point of the circle.

      {\it (type=Scientific.Geometry.Vector object)}

      \end{quote}

    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:randomDirection2D}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.randomDirection2D \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{randomDirection2D}(\textit{axis})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns a normalized vector drawn from an uniform distribution on the 
    surface of a unit circle on a plane orthogonal to 
    {\textbar}axis{\textbar}.

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxx}

          \item[axis]

          the axis orthogonal to the plane where the vectors have to be 
          generated.

            {\it (type=Scientific.Geometry.Vector object)}

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      A normalized vector defined in a unit disk orthogonal to 
      {\textbar}axis{\textbar}

      {\it (type=Scientific.Geometry.Vector object)}

      \end{quote}

    \end{boxedminipage}

    \label{nMOLDYN:Core:Mathematics:randomVector}
    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}!nMOLDYN.Core.Mathematics.randomVector \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{randomVector}(\textit{directions}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns a normalized random vector on a plane or in space.

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxxxxxx}

          \item[directions]

          if not None, a list of 2 Scientific.Vector that will define the 
          plane on which the vector should be generated.

            {\it (type=list of 2 Scientific.Vector or None)}

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      a normalized random vector on a plane defined by 
      {\textbar}directions{\textbar} or in space 
      ({\textbar}directions{\textbar} = None).

      {\it (type=Scientific.Geometry.Vector object)}

      \end{quote}

    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright a\-2\- & \raggedright a3 = array used to perform order 3 numerical differentiation 
          scheme.

\textbf{Value:} 
{\tt N.array([[-3., 4.,-1.], [-1., 0., 1.], [1.,-4., 3.]])}&\\
\cline{1-2}
\raggedright a\-3\- & \raggedright a4 = array used to perform order 4 numerical differentiation 
          scheme.

\textbf{Value:} 
{\tt N.array([[-11., 18.,-9., 2.], [-2.,-3., 6.,-1.], [1.,-6.,\texttt{...}}&\\
\cline{1-2}
\raggedright a\-4\- & \raggedright a5 = N.array used to perform order 5 numerical differentiation 
          scheme.

\textbf{Value:} 
{\tt N.array([[-50., 96.,-72., 32.,-6.], [-6.,-20., 36.,-12., \texttt{...}}&\\
\cline{1-2}
\raggedright a\-5\- & \raggedright \textbf{Value:} 
{\tt N.array([[-274., 600.,-600., 400.,-150., 24.], [-24.,-130\texttt{...}}&\\
\cline{1-2}
\end{longtable}

    \index{nMOLDYN \textit{(package)}!nMOLDYN.Core \textit{(package)}!nMOLDYN.Core.Mathematics \textit{(module)}|)}
